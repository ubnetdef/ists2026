<#
BaselineDiff.ps1 (hardened)
Baseline inventory + diff scanner. Optionally flag-hunt and optionally remove NEW files with ONE confirmation.

USAGE:
  # Baseline
  .\BaselineDiff.ps1 -Mode Baseline -Drive C -OutDir .\baseline_win11

  # Diff + ranked report + optional flag scan
  .\BaselineDiff.ps1 -Mode Diff -Drive C -BaselineDir .\baseline_win11 -OutDir .\diffout -FlagRegex 'ISTS\{[^}]+\}'

  # Diff but skip hashing
  .\BaselineDiff.ps1 -Mode Diff -Drive C -BaselineDir .\baseline_win11 -OutDir .\diffout -Fast

NOTES:
- Run elevated for best coverage.
- This script can delete files if you answer YES at the end.
#>

[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)]
  [ValidateSet("Baseline","Diff")]
  [string]$Mode,

  [Parameter(Mandatory=$true)]
  [string]$Drive,   # "C" or "C:"

  [string]$BaselineDir,

  [Parameter(Mandatory=$true)]
  [string]$OutDir,

  [switch]$Fast,

  [string[]]$ExcludePaths = @(
    "\Windows\WinSxS",
    "\Windows\Installer",
    "\System Volume Information",
    "\Windows\SoftwareDistribution"   # reduces noise; safe to exclude for baseline diff
  ),

  [string]$FlagRegex,

  # Removal behavior (ONE prompt at end)
  [switch]$OfferRemove,              # if set, script will ask once at the end whether to delete NEW files
  [int]$RemoveMinScore = 0,          # if OfferRemove, only delete new files with Score >= this
  [switch]$DryRun                    # if OfferRemove, show what would be deleted but don't delete
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$MAX_FLAG_SCAN_BYTES = 25MB

function Normalize-Drive([string]$d) {
  $d = $d.Trim()
  if ($d.Length -eq 1) { return "$d`:" }
  if ($d.EndsWith(":")) { return $d }
  return $d
}

function Ensure-Dir([string]$p) {
  if (!(Test-Path -LiteralPath $p)) { New-Item -ItemType Directory -Path $p | Out-Null }
}

function Normalize-Root([string]$drv) {
  $drv = Normalize-Drive $drv
  return "$drv\"
}

function Is-Excluded([string]$fullPath, [string]$root, [string[]]$excludes) {
  foreach ($ex in $excludes) {
    $exNorm = ($root.TrimEnd('\') + ($ex -replace '/', '\')).Replace("\\","\")
    if ($fullPath.StartsWith($exNorm, [System.StringComparison]::OrdinalIgnoreCase)) {
      return $true
    }
  }
  return $false
}

function Get-Inventory([string]$root, [string[]]$excludes, [switch]$fast) {
  $items = New-Object System.Collections.Generic.List[object]

  # Stream enumeration and skip reparse points to avoid junction loops
  $enum = Get-ChildItem -LiteralPath $root -Recurse -Force -File -ErrorAction SilentlyContinue |
          Where-Object { -not $_.Attributes.HasFlag([IO.FileAttributes]::ReparsePoint) }

  foreach ($f in $enum) {
    try {
      if (Is-Excluded -fullPath $f.FullName -root $root -excludes $excludes) { continue }

      # Safer relative path compute
      $rel = $f.FullName
      if ($rel.StartsWith($root, [System.StringComparison]::OrdinalIgnoreCase)) {
        $rel = $rel.Substring($root.Length).TrimStart('\')
      } else {
        # Fallback: shouldn't happen, but avoid throwing
        $rel = $f.Name
      }

      $hash = $null
      if (-not $fast) {
        try {
          $hash = (Get-FileHash -LiteralPath $f.FullName -Algorithm SHA256 -ErrorAction Stop).Hash
        } catch {
          $hash = $null
        }
      }

      $items.Add([pscustomobject]@{
        Path            = $rel
        Length          = [int64]$f.Length
        LastWriteTimeUtc= $f.LastWriteTimeUtc
        HashSHA256      = $hash
      })
    } catch {
      # swallow per-file issues
    }
  }

  return $items
}

function Save-Inventory($inv, [string]$outPath) {
  $inv | Select-Object Path,Length,
    @{n="LastWriteTimeUtc";e={$_.LastWriteTimeUtc.ToString("o")}},
    HashSHA256 |
    Export-Csv -NoTypeInformation -Encoding UTF8 -Path $outPath
}

function Load-Inventory([string]$csvPath) {
  # Cast types back (CSV imports as strings)
  Import-Csv -Path $csvPath | ForEach-Object {
    [pscustomobject]@{
      Path            = $_.Path
      Length          = [int64]($_.Length)
      LastWriteTimeUtc= [datetime]($_.LastWriteTimeUtc)
      HashSHA256      = if ($_.HashSHA256 -and $_.HashSHA256.Trim().Length -gt 0) { $_.HashSHA256 } else { $null }
    }
  }
}

function Build-Map($inv) {
  $map = @{}
  foreach ($r in $inv) { $map[$r.Path] = $r }
  return $map
}

function Diff-Inventories($baseInv, $curInv, [switch]$fast) {
  $baseMap = Build-Map $baseInv
  $curMap  = Build-Map $curInv

  $newFiles = New-Object System.Collections.Generic.List[object]
  $modified = New-Object System.Collections.Generic.List[object]
  $missing  = New-Object System.Collections.Generic.List[object]

  foreach ($p in $curMap.Keys) {
    if (-not $baseMap.ContainsKey($p)) {
      $newFiles.Add($curMap[$p])
      continue
    }

    $b = $baseMap[$p]
    $c = $curMap[$p]

    if ($fast) {
      if (($b.Length -ne $c.Length) -or ($b.LastWriteTimeUtc -ne $c.LastWriteTimeUtc)) {
        $modified.Add([pscustomobject]@{
          Path=$p; BaseLength=$b.Length; CurLength=$c.Length;
          BaseLastWrite=$b.LastWriteTimeUtc; CurLastWrite=$c.LastWriteTimeUtc;
          BaseHash=$b.HashSHA256; CurHash=$c.HashSHA256
        })
      }
    } else {
      $hashChanged = ($b.HashSHA256 -and $c.HashSHA256 -and ($b.HashSHA256 -ne $c.HashSHA256))
      $metaChanged = (($b.Length -ne $c.Length) -or ($b.LastWriteTimeUtc -ne $c.LastWriteTimeUtc))

      if ($hashChanged -or ($metaChanged -and (-not $b.HashSHA256 -or -not $c.HashSHA256))) {
        $modified.Add([pscustomobject]@{
          Path=$p; BaseLength=$b.Length; CurLength=$c.Length;
          BaseLastWrite=$b.LastWriteTimeUtc; CurLastWrite=$c.LastWriteTimeUtc;
          BaseHash=$b.HashSHA256; CurHash=$c.HashSHA256
        })
      }
    }
  }

  foreach ($p in $baseMap.Keys) {
    if (-not $curMap.ContainsKey($p)) { $missing.Add($baseMap[$p]) }
  }

  [pscustomobject]@{ NewFiles=$newFiles; Modified=$modified; Missing=$missing }
}

function Score-Suspicious([string]$relPath) {
  $p = $relPath.ToLowerInvariant()
  $score = 0
  if ($p -match "appdata\\(roaming|local|locallow)") { $score += 3 }
  if ($p -match "\\programdata\\") { $score += 2 }
  if ($p -match "\\users\\public\\") { $score += 2 }
  if ($p -match "\\temp\\|\\tmp\\") { $score += 3 }
  if ($p -match "\\startup\\") { $score += 4 }
  if ($p -match "\\windows\\tasks\\|\\windows\\system32\\tasks\\") { $score += 4 }
  if ($p -match "\\windows\\system32\\drivers\\") { $score += 2 }
  if ($p -match "\\windows\\system32\\") { $score += 1 }
  if ($p -match "\.(ps1|vbs|js|jse|wsf|hta|bat|cmd|scr|dll|sys|exe|lnk)$") { $score += 2 }
  return $score
}

function Find-Flags([string]$root, $paths, [string]$regex, [string]$outPath) {
  $results = New-Object System.Collections.Generic.List[object]
  foreach ($r in $paths) {
    $full = Join-Path $root $r.Path
    try {
      if (-not (Test-Path -LiteralPath $full)) { continue }
      $len = [int64]$r.Length
      if ($len -gt $MAX_FLAG_SCAN_BYTES) { continue }

      $bytes = [System.IO.File]::ReadAllBytes($full)
      $text  = [System.Text.Encoding]::UTF8.GetString($bytes)

      foreach ($match in [regex]::Matches($text, $regex)) {
        $results.Add([pscustomobject]@{ Path=$r.Path; Match=$match.Value })
      }
    } catch { }
  }
  $results | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $outPath
}

function Remove-NewFilesOnce([string]$root, $ranked, [int]$minScore, [switch]$dryRun) {
  $targets = $ranked | Where-Object { $_.Score -ge $minScore }

  if (-not $targets -or $targets.Count -eq 0) {
    Write-Host "[*] No NEW files meet removal threshold (Score >= $minScore)."
    return
  }

  Write-Host ""
  Write-Host "[!] Removal offer enabled."
  Write-Host ("[*] {0} NEW files would be removed (Score >= {1})." -f $targets.Count, $minScore)
  $ans = Read-Host "Type YES to remove them (or anything else to cancel)"
  if ($ans -ne "YES") {
    Write-Host "[*] Removal cancelled."
    return
  }

  foreach ($t in $targets) {
    $full = Join-Path $root $t.Path
    try {
      if ($dryRun) {
        Write-Host "[DRYRUN] Would remove $full"
      } else {
        if (Test-Path -LiteralPath $full) {
          Remove-Item -LiteralPath $full -Force -ErrorAction SilentlyContinue
        }
      }
    } catch { }
  }

  if ($dryRun) {
    Write-Host "[+] Dry-run complete."
  } else {
    Write-Host "[+] Removal complete."
  }
}

# ---------------- main ----------------
$root = Normalize-Root $Drive
Ensure-Dir $OutDir

$invPath  = Join-Path $OutDir "inventory.csv"
$metaPath = Join-Path $OutDir "runinfo.txt"

@(
  "Mode=$Mode"
  "Root=$root"
  "Fast=$Fast"
  "ExcludePaths=$($ExcludePaths -join ';')"
  "TimeUtc=$([DateTime]::UtcNow.ToString('o'))"
) | Out-File -Encoding UTF8 -FilePath $metaPath

Write-Host "[*] Enumerating files under $root ..."
$inv = Get-Inventory -root $root -excludes $ExcludePaths -fast:$Fast
Write-Host ("[*] Collected {0} files" -f $inv.Count)

Write-Host "[*] Saving inventory to $invPath"
Save-Inventory -inv $inv -outPath $invPath

if ($Mode -eq "Baseline") {
  Write-Host "[+] Baseline created in $OutDir"
  exit 0
}

if (-not $BaselineDir) { throw "BaselineDir is required for Mode=Diff" }

$baselineCsv = Join-Path $BaselineDir "inventory.csv"
if (-not (Test-Path -LiteralPath $baselineCsv)) { throw "Baseline inventory not found: $baselineCsv" }

Write-Host "[*] Loading baseline inventory: $baselineCsv"
$baseInv = Load-Inventory $baselineCsv

Write-Host "[*] Diffing inventories..."
$diff = Diff-Inventories -baseInv $baseInv -curInv $inv -fast:$Fast

$newOut  = Join-Path $OutDir "new_files.csv"
$modOut  = Join-Path $OutDir "modified_files.csv"
$misOut  = Join-Path $OutDir "missing_files.csv"
$rankOut = Join-Path $OutDir "new_files_ranked.csv"

$diff.NewFiles | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $newOut
$diff.Modified | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $modOut
$diff.Missing  | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $misOut

Write-Host ("[+] New files: {0}  Modified: {1}  Missing: {2}" -f $diff.NewFiles.Count, $diff.Modified.Count, $diff.Missing.Count)
Write-Host "[+] Reports written:"
Write-Host "    $newOut"
Write-Host "    $modOut"
Write-Host "    $misOut"

# Rank new files
$ranked = $diff.NewFiles | ForEach-Object {
  [pscustomobject]@{
    Score = (Score-Suspicious $_.Path)
    Path  = $_.Path
    Length= $_.Length
    LastWriteTimeUtc = $_.LastWriteTimeUtc
    HashSHA256 = $_.HashSHA256
  }
} | Sort-Object Score -Descending, LastWriteTimeUtc -Descending

$ranked | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $rankOut
Write-Host "    $rankOut"

# Show a quick on-screen summary (top 30)
Write-Host ""
Write-Host "[*] Top suspicious NEW files (top 30):"
$ranked | Select-Object -First 30 | Format-Table -AutoSize Score,Length,LastWriteTimeUtc,Path

# Optional flag scan
if ($FlagRegex) {
  $flagOut = Join-Path $OutDir "flag_hits.csv"
  Write-Host ""
  Write-Host "[*] Scanning NEW+MODIFIED for regex: $FlagRegex (<= $MAX_FLAG_SCAN_BYTES per file)"

  $toScan = New-Object System.Collections.Generic.List[object]
  foreach ($n in $diff.NewFiles) { $toScan.Add($n) }
  foreach ($m in $diff.Modified) {
    $cur = $inv | Where-Object { $_.Path -eq $m.Path } | Select-Object -First 1
    if ($cur) { $toScan.Add($cur) }
  }

  Find-Flags -root $root -paths $toScan -regex $FlagRegex -outPath $flagOut
  Write-Host "[+] Flag scan report:"
  Write-Host "    $flagOut"
}

# ONE-TIME removal prompt (only if requested)
if ($OfferRemove) {
  Remove-NewFilesOnce -root $root -ranked $ranked -minScore $RemoveMinScore -dryRun:$DryRun
}

Write-Host ""
Write-Host "[+] Done."